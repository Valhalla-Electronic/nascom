# RTL Simulation of NASCOM 1 and NASCOM 2 video sub-systems

## Introduction

Although I have stared at the NASCOM 1 and NASCOM 2 schematics, and understand
in general terms how the video circuitry works, the fine detail of it has always
eluded me.

In particular, I'd like to know: how did we end up with row 16 at the top of the
screen instead of at the bottom? There is no sensible reason for choosing to do
it like this. Was it a design bug, not found until too late? Was it a
side-effect of saving a chip or two?

To find out, and understand the operation better, I wrote a verilog net-list of
the NASCOM 1 video schematic, created models of the components and ran an RTL
simulation. I used the open-source "Icarus Verilog" simulator and the
open-source GTKWave viewing tool.

Some time later, I did the same with the NASCOM 2 video schematic.

I present some .pdf files that show the video timing in gory detail. I also
present the netlists and models in case anyone wants to develop the idea further.

## Files

* nas1_vid.v nas2_vid.v -- Verilog netlist of the NASCOM 1/NASCOM 2 video
  sub-systems. Created by hand from examination of the schematics. I have named
  all of the signals. To make detailed sense of it you need to print out some N1/N2
  schematics and annotate the names by inspecting the appropriate .v file.

* nas1_vid_tb.v nas2_vid_tb.v -- Verilog test-bench to control the simulation,
  apply clocks, gather waveforms.

* doitall1 -- script to build and run the NASCOM 1 video simulation.

* doitall2 -- script to build and run the NASCOM 2 video simulation.

* doc/ -- contains .pdf files of waveforms, so that you can see the results of
  the simulation without having to run it yourself. These are described in
  detail below.

* other *.v files are (simple) verilog models of the components that make up the video
  sub-system(s).


## Overview (NASCOM 1 and NASCOM 2)

A couple of things to note: Firstly, this is only a functional (logical)
simulation, there is no timing information (i.e., the Verilog models do not
model the timing of the TTL gates, only their behaviour). Secondly, I have not
(yet) troubled to model the video RAM or the character generator; I have just
put fixed data on the output of the character generator.

The NASCOM video circuit produces 16 lines of characters, with 48
characters per line. The horizontal timing is 64 character-times long and the
RAM access continues during the non-visible region, so that each line of
characters starts in RAM on a multiple of 64 (which is convenient, because it's
a power of 2).

Each line of characters is made up (vertically) of a sequence of raster
scan-lines on the video output and (horizontally) of 8 dots of light (1) or not
(0) on the phosphor of the CRT.

For the NASCOM 1, there are 16 raster scan-lines for each line of
characters. For the NASCOM 2 there are either 12 or 14 raster scan lines for
each line of characters (12 for French 525/60Hz video, 14 for UK 625/50Hz
video). In all cases, there is no additional vertical spacing between the lines
of characters.

This difference in the number of scan-lines explains why the stick figure
characters (0xb5, 0xb6, 0xb7) have feet on the NASCOM 1 but are footless on the
NASCOM 2.

The scan-lines of a line are generated by reading the same sequence of 64 video
RAM locations repeatedly (16 times on the NASCOM 1, 12 or 14 times on the NASCOM
2). Each time, the RAM returns the same value (the ASCII code of the character
to be displayed) and a 4-bit counter increments.  Together, the ASCII code and
the 4-bit count are used to address the character generator, to get an 8-bit
value. This value is loaded into a shift register and clocked to give 8 pixel
values for 1/64th part of this scan-line. Blanking signals gate the pixel data
to 0 (black) for 16 character-times, leaving 48 character-times of display.

The descriptions and waveforms assume no video RAM access from the Z80 CPU; the
effect of CPU access is described separately.

## NASCOM 1 simulation waveforms

Successive pictures 'zoom in' to parts of the frame:

* doc/startup_frames.pdf    -- shows the 50 frame/second timing start up after 2 frame-times
* doc/single_frame.pdf      -- shows the timing for the active part of a single frame
* doc/single_line.pdf       -- shows the timing for one output line, 16 scan-lines
* doc/single_scanline.pdf   -- shows the timing for one scan-line
* doc/hblank_to_7chars.pdf  -- shows the start of one scan-line
* doc/14chars_to_hblank.pdf -- shows the end of one scan-line

### startup_frames.pdf

IC6, IC19, IC18 generate "clk_1mhz_pulse" which is used as the clock for a
divider chain IC1, IC2, IC3, IC4. The carry/load signals for this divider chain
are arranged so that IC4/12, "div16" has a period of 50Hz -- the frame rate.
Observe that it takes several cycles (several frame times) for the correct
frequency to be established -- the correct timing has been established when the
low-time of "div16" is shorter than the high-time.

The simulation test bench reports the frame period, which stabilises at 19968us
(50.08Hz).

The black regions of the waveform show signals that are toggling too quickly for
all the transitions to be visible at this zoom level. The shaded regions (on
active_v) show a signal in an undefined state; it takes the av_set pulse to
bring this latch into a known state.

The three "count" busses are the internal counters of the divider chain formed
by IC2, IC3, IC4.

### single_frame.pdf

"active_v" shows the active part of 1 frame (i.e., everything
apart from vertical blanking). "active_h" shows the active part of each scan-line
in the frame (and therefore there should be 16 lines * 16 scan-lines of them
within a frame).

"vdu_line" is the part of the address that defines the output line that is being
read from the video RAM. Immediately, one mystery of the NASCOM video addressing
is revealed: this bus counts from f (15) through 0 and up to e during the active
part of the frame. This shows how "line 16" comes to be at the top of the
frame. The waveforms also suggest that if "av_clr" and "av_set" were swapped,
the active region would be shifted along by 1 row time, so that "line 16" would
be at the bottom of the screen. ("av_clr", "av_set" are the outputs from IC8,
IC9).

I wonder whether this mod. would be sufficient, or whether it would also be
necessary to adjust the position of the vertical sync pulse?

### single_line.pdf

Shows one output line of characters, made up of 16 scan-lines. When "vdu_line"
has a value of f, the top line of the frame is being generated. "chr_rs" counts
from 0 through f, generating the row selects into the character
generator. "active_v" asserts and remains asserted because this is the start of
a video frame. "active_h" pulses high 16 times; once for each scan-line. "s2" is
the horizontal sync pulse. "vid_data" is toggling during the active part of each
line (it is gated out by "active_h", "active_v" the rest of the time, by IC11c).

### single_scanline.pdf

Shows one scan line. "vdu_line" is f and "chr_rs" is 0, showing that this is the
first scan-line at the top of the frame; this is confirmed by seeing "active_v"
assert. "ah_set", "ah_clr" 'bracket' the active part of the line, making
"active_h" assert. "clk_char_ld" pulses once per character. The resolution's a
bit low, but it should be possible to see:

* "mux_a" (the video RAM address) count though the locations of one row in one
period of "active_h"

* 64 pulses on "clk_char_ld" in one period of active_h

* (of which) 48 pulses occur while "active_h" is high

Remember, the operation of the video RAM, character generator etc. continues
through horizontal blanking; it's simply not visible because it's gated out of
"vid_data".

### hblank_to_7chars.pdf

Zooms in further to the start of the first scan line. As before, "vdu_line" is
f, "chr_rs" is 0, "active_v" asserts. The first visible character for line 16
comes from video RAM address 0x0bca. The base address of the video RAM is 0x800,
so address 0x0bca corresponds to address 0x3ca in the video RAM. Observe the
value 0x3ca on "mux_a". Where the value changes from 0x3ca to 0x3cb, the data
(the ASCII code for the first character to be displayed) is clocked into IC17
and used, along with the 0 from "chr_rs", to access a location in the character
generator. One character time later (when "mux_a" changes to 0x3cc) the
bit-pattern from the character generator is loaded into the shift register IC15
and "active_h" goes high, so that the display is enabled for the first dot of
the first scan-line of the first row of the first line.

In the simulation models, the output from the character generator is a constant
0x55 pattern, giving 3 high-pulses on "vid_data" for each output character.

TODO explain where the extra bit comes from.. the waves and the description
don't match..

### 14chars_to_hblank.pdf

Shows the end of the first scan line. The value 0x3f9 on "mux_a" corresponds to
the (first scan-line of the) last character on line 16, and the same 'pipe-line'
occurs as before, so that "active_h" goes low after the last dot of the
character is shifted out of the shift register.

## NASCOM 2 simulation waveforms

As of April 2020 this is a Coronavirus Lockdown work-in-progress project. The N2
sim is just about working but with some bugs. Hassle me to make progress if you
are interested!

The NASCOM 2 video design is software compatible with the NASCOM 1. Its
implementation is slightly different (it uses a small PROM as a logic decoder to
reduce the component count). Functionally, there are two differences:

* The number of video scan-lines per character line is either 12 or 14; on the
  NASCOM 1 it is fixed at 16.

* The way of coping with contention from CPU accesses is different. On the
  NASCOM 1 CPU contention caused white streaks ("snow") on the display. On the
  NASCOM 2 CPU contention caused parts of the scan line to be blanked -- less
  objectionable but not ideal; in the limit, executing code from the VDU RAM
  caused the screen to be permanently blanked.

Successive pictures 'zoom in' to parts of the frame:

* doc/n2startup_frames.pdf    -- shows the 50 frame/second timing for 2 frame-times
* doc/n2single_frame.pdf      -- shows the timing for the active part of a single frame
* doc/n2single_line.pdf       -- shows the timing for one output line, 16 scan-lines
* doc/n2single_scanline.pdf   -- shows the timing for one scan-line
* doc/n2hblank_to_7chars.pdf  -- shows the start of one scan-line
* doc/n214chars_to_hblank.pdf -- shows the end of one scan-line

### n2startup_frames.pdf

Two section of IC65 forms a crystal oscillator running at a frequency of
16MHz. This is divided by IC49 to generate clocks at 8MHz, 4MHz, 2MHz and 1MHz,
each with a nominal 50/50 duty cycle. A LSW selects between 2MHz and 4MHz clocks
for the CPU clock.

"clk_8mhz" is used as the dot clock and clocks the video shift register, IC65.

"clk_1mhz_pulse" has a short, low-going pulse at a 1MHz rate. It is used to
clock the dividers for the video timing chain.

IC71a combines the 1, 2, 4 and 8MHz clocks together to generate "clk_char_ld"
which has a short low-going pulse at a 1MHz rate (later waveforms show the
relationship between "clk_1mhz_pulse" and "clk_char_ld"). This is used to load
the video shift register, IC65.

IC51, IC52, IC53, IC68 form a divider chain that times a frame's active and
blanking time. The period of "vblank_n" shows the frame period. The simulation
test bench reports this period, which stabilises at 19712us (50.73Hz).

The falling edge of "vsync_trigger_n" triggers monostable IC57 to generate
"vsync", the vertical sync pulse to the vdu.

The black regions of the waveform show signals that are toggling too quickly for
all the transitions to be visible at this zoom level.

### n2single_frame.pdf

"active_v" shows the active part of 1 frame (i.e., everything apart from
vertical blanking). "active_h" shows the active part of each scan-line in the
frame (and therefore there should be 16 lines * 14 scan-lines of them within a
frame).

"vdu_line" is the part of the address that defines the output line that is being
read from the video RAM. This bus counts from f (15) through 0 and up to e
during the active part of the frame, with the result that "line 16" is at the
top of the frame, as on the NASCOM 1.

TODO more about how the counters work and the role of the PROM.

### n2single_line.pdf

Shows one output line of characters, made up of 14 scan-lines. When "vdu_line"
has a value of f, the top line of the frame is being generated. "chr_rs" counts
from 0 through d, generating the row selects into the character
generator. "active_v" asserts and remains asserted because this is the start of
a video frame. "active_h" pulses high 14 times; once for each scan-line.
"vid_shift_data" is the output of the shift register, IC65. It is combined with
"active_h" and "active_v" in IC61a to generate "vid_data" which is the video
data for the display: there are 14 bursts of activity, one for each scan-line of
the output.

### n2single_scanline.pdf

Shows one scan line. "vdu_line" is f and "chr_rs" is 0, showing that this is the
first scan-line at the top of the frame; this is confirmed by seeing "active_v"
assert.

The falling edge of "div7" triggers monostable IC57 to generate "hsync", the
horizontal sync pulse to the vdu. "hsync" is combined with "vsync" in IC61c to
generate "vid_sync" to the video output and video modulator. The voltage swing
distinguishes sync from video, and the pulse width distinguishes horizontal from
vertical sync pulses.

"active_h" is generated from a set/reset latch IC60a,b. The latch is set by
"ah_set_n" and cleared by "ah_clr_n" which are decodes of timing chain count
values, generated by IC55a,b.

"clk_char_ld" pulses once per character. The resolution's a bit low, but it
should be possible to see:

* "mux_a" (the video RAM address) count though the locations of one row in one
period of "active_h"

* 64 pulses on "clk_char_ld" in one period of active_h

* (of which) 48 pulses occur while "active_h" is high

Remember, the operation of the video RAM, character generator etc. continues
through horizontal blanking; it's simply not visible because it's gated out of
"vid_data".

### n2hblank_to_7chars.pdf

Zooms in further to the start of the first scan line. As before, "vdu_line" is
f, "chr_rs" is 0, "active_v" asserts. The first visible character for line 16
comes from video RAM address 0x0bca. The base address of the video RAM is 0x800,
so address 0x0bca corresponds to address 0x3ca in the video RAM, IC50. Pins
A[9:6] of the RAM select the line of the display (0-15) and pins A[5:0] select
the charactor on the line (0-63).

Observe the value 0x3ca on "mux_a". Where the value changes from 0x3ca to 0x3cb,
the data from the RAM, on chr_d (the ASCII code for the first character to be
displayed) is clocked into IC67 on the rising edge of "clk_char_ld". The output,
"chr_a" is used as part of the address for the character generator ROMs.

"chr_a[7]" (from bit[7] of the byte stored in the video RAM) selects between the
alphanumerics character generator ROM and the NAS-GRA ROM. For each 2Kbyte ROM,
the 4-bit "chr_rs" is connected to the low-order address lines to select one of
16 rows (though only 14 are used). "chr_a[6:0]" provide the other 7 address
lines, selecting one of 128 characters in the particular ROM.

One character time later (when "mux_a" changes to 0x3cc) the bit-pattern from
the character generator is loaded into the shift register IC65 and "active_h"
goes high, so that the display is enabled for the first dot of the first
scan-line of the first row of the first line.

In the simulation models, the output from the character generator is a constant
0x93 pattern. Shift register IC65 serialises its H input first, which is the MSB
from the character generator. So, the 0x93 is serialised MSB first, as 10010011.

In the simulation models, the output from the character generator is a constant
0x55 pattern, giving 3 high-pulses on "vid_data" for each output character.

### n2char_pipeline.pdf

Zooms in further to show the pipeline from the first visible character being
addressed, to that characters data coming out of the shift register.

### n214chars_to_hblank.pdf

Shows the end of the first scan line. The value 0x3f9 on "mux_a" corresponds to
the (first scan-line of the) last character on line 16, and the same pipe-line
occurs as before, so that "active_h" goes low after the last dot of the
character is shifted out of the shift register.

## Z80 access to video RAM (no .pdf for this)

Access to the video RAM is shared between the video circuitry and the Z80
CPU. The CPU has read-write access and the video circuitry has read-only
access. CPU access takes priority; when the CPU accesses the video RAM, /VRAM
asserts (a decode of /MREQ and the address bus). These things happen:

* /VRAM switches the address MUXes IC62, IC63, IC64 so that the address to the
  video RAM is supplied by the CPU instead of the video address counters.

* /VRAM triggers a monostable chain formed by IC58b, IC58a (more on that later).

* /VRAM enables the data buffer, IC70 pin 11, and inverted CPU /RD controls its
  direction (pin 11) to allow data from the CPU to flow through to the video RAM
  data bus, or the reverse.

* /VRAM is gated with the CPU write strobe (IC59c) to generate the video RAM
  /WE. If /VRAM is high (no CPU access), /WE is negated. If /VRAM is low (CPU
  access), /WE follows the CPU /WR strobe.

* /VRAM is gated with the CPU read strobe (IC69b on sheet 3) to generate the
video RAM /OE. If /VRAM is high (no CPU access), /OE is asserted. If /VRAM is low
(CPU access), /OE follows the CPU /RD strobe.

IC67 continues to clock values to address the character generator, even when CPU
accesses occur. As a result, incorrect values get clocked into IC67, which
result in corrupted pixels in the video stream. The purpose of monostables IC58
is to prevent these corrupted pixels from appearing on the display. A CPU access
triggers a high-going pulse on IC58/5. The end of the pulse triggers a low-going
pulse on IC58/4. This pulse is gated with the horizontal and vertical blanking
signals in IC61a. The effect of the monostables is to insert a black region in
the scan-line which should coincide with the time at which the corrupted data is
being shifted out of IC65. The pulse width of IC58b should delay the start of
the black region, to correspond to the pipeline delay between the data
corruption and the output of the video RAM IC50 and the associated data
corruption at the output of the shift register IC65. The pulse width of IC58a
should correspond to 8 bit-times.

TODO in practise, both of those times are longer than I would expect to be
necessary. Strictly, the best times are a function of the CPU frequency.

This part of the design fixes the "white snow" effect seen on the NASCOM 1 but
excessive CPU access to video RAM causes the blanking pulses to be noticable,
particularly on a display where many pixels are lit. A simple test program that
accesses the video RAM can show this:

````
  0c80   3a 00 08  ld a, (£0800)
  0c83   32 00 08  ld (£0800), a
  0c86   00        nop
  0c87   00        nop
  0c88   00        nop
  0c89   00        nop
  0c8a   00        nop
  0c8b   00        nop
  0c8c   c3 80 0c  jp £0c80
````

When executed, black stripes appear on the screen.


## How to run it yourself

I use Linux. Your mileage may vary.

* Download and install Icarus Verilog

* Download and install GTKWave

Do this:

    $ ./doitall1                         # or ./doitall2
    (wait)
    (load the .vcd file into GTKWave)


## Futures

* Generate some Z80 bus traffic to show it interfering with the video
access.

* Model the RAM and character generator

* The counters have an "initial" statement in them to establish the count at
time 0. It would be better to put a 'force' into the test-bench as it would be
more apparent what is going on (search for CHEAT and CHEATING in the code).

* Describe CPU accesss to video RAM and discuss the shortcomings of CPU
contention mitigation which causes white snow on the NASCOM 1 and black snow(??)
on the NASCOM 2.

* Rework the N1 waves to make them clearer, and explain/debug the issue with
shift register load.


## Comments/improvements

* Email me or use the 'issues' button at the top on the github page.

* Fork the project and make a merge request
