# RTL Simulation of NASCOM 1 and NASCOM 2 video sub-systems

## Introduction

Although I have stared at the NASCOM 1 and NASCOM 2 schematics, and understand
in general terms how the video circuitry works, the fine detail of it has always
eluded me.

In particular, I'd like to know: how did we end up with row 16 at the top of the
screen instead of at the bottom? There is no sensible reason for choosing to do
it like this. Was it a design bug, not found until too late? Was it a
side-effect of saving a chip or two?

To find out, and understand the operation better, I wrote a verilog net-list of
the NASCOM 1 video schematic, created models of the components and ran an RTL
simulation. I used the open-source "Icarus Verilog" simulator and the
open-source GTKWave viewing tool.

Some time later, I did the same with the NASCOM 2 video schematic. For the
NASCOM 2 design, I wanted to understand the function of the N2V PROM and the
circuit that blanks the video during a CPU access.

I present some .pdf files that show the video timing in gory detail. I also
present the netlists and models in case anyone wants to develop the idea further.

## Files

* nas1_vid.v nas2_vid.v -- Verilog netlist of the NASCOM 1/NASCOM 2 video
  sub-systems. Created by hand from examination of the schematics. I have named
  all of the signals. To make detailed sense of it you need to print out some N1/N2
  schematics and annotate the names by inspecting the appropriate .v file.

* nas1_vid_tb.v nas2_vid_tb.v -- Verilog test-bench to control the simulation,
  apply clocks, gather waveforms.

* doitall1 -- script to build and run the NASCOM 1 video simulation.

* doitall2 -- script to build and run the NASCOM 2 video simulation.

* doc/ -- contains .pdf files of waveforms, so that you can see the results of
  the simulation without having to run it yourself. These are described in
  detail below.

* other *.v files are (simple) verilog models of the components that make up the video
  sub-system(s).


## Overview (NASCOM 1 and NASCOM 2)

A couple of things to note: Firstly, this is only a functional (logical)
simulation, there is no timing information (i.e., the Verilog models do not
model the timing of the TTL gates, only their behaviour). Secondly, I have not
(yet) troubled to model the video RAM or the character generator; I have just
put fixed data on the output of the character generator.

The NASCOM video circuit produces 16 lines of characters, with 48
characters per line. The horizontal timing is 64 character-times long and the
RAM access continues during the non-visible region, so that each line of
characters starts in RAM on a multiple of 64 (which is convenient, because it's
a power of 2).

Each line of characters is made up (vertically) of a sequence of raster
scan-lines on the video output and (horizontally) of 8 dots of light (1) or not
(0) on the phosphor of the CRT.

For the NASCOM 1, there are 16 raster scan-lines for each line of
characters. For the NASCOM 2 there are either 12 or 14 raster scan lines for
each line of characters (12 for French 525/60Hz video, 14 for UK 625/50Hz
video). In all cases, there is no additional vertical spacing between the lines
of characters.

This difference in the number of scan-lines explains why the stick figure
characters (0xb5, 0xb6, 0xb7) have feet on the NASCOM 1 but are footless on the
NASCOM 2.

The scan-lines of a line are generated by reading the same sequence of 64 video
RAM locations repeatedly (16 times on the NASCOM 1, 12 or 14 times on the NASCOM
2). Each time, the RAM returns the same value (the ASCII code of the character
to be displayed) and a 4-bit counter increments.  Together, the ASCII code and
the 4-bit count are used to address the character generator, to get an 8-bit
value. This value is loaded into a shift register and clocked to give 8 pixel
values for 1/64th part of this scan-line. Blanking signals gate the pixel data
to 0 (black) for 16 character-times, leaving 48 character-times of display.

The descriptions and waveforms assume no video RAM access from the Z80 CPU; the
effect of CPU access is described separately.

## NASCOM 1 simulation waveforms

Successive pictures 'zoom in' to parts of the frame:

* doc/startup_frames.pdf    -- shows the 50 frame/second timing start up after 2 frame-times
* doc/single_frame.pdf      -- shows the timing for the active part of a single frame
* doc/single_line.pdf       -- shows the timing for one output line, 16 scan-lines
* doc/single_scanline.pdf   -- shows the timing for one scan-line
* doc/hblank_to_7chars.pdf  -- shows the start of one scan-line
* doc/14chars_to_hblank.pdf -- shows the end of one scan-line

### startup_frames.pdf

IC6, IC19, IC18 generate "clk_1mhz_pulse" which is used as the clock for a
divider chain IC1, IC2, IC3, IC4. The carry/load signals for this divider chain
are arranged so that IC4/12, "div16" has a period of 50Hz -- the frame rate.
Observe that it takes several cycles (several frame times) for the correct
frequency to be established -- the correct timing has been established when the
low-time of "div16" is shorter than the high-time.

The simulation test bench reports the frame period, which stabilises at 19968us
(50.08Hz).

The black regions of the waveform show signals that are toggling too quickly for
all the transitions to be visible at this zoom level. The shaded regions (on
"active_v") show a signal in an undefined state; it takes the "av_set" pulse to
bring this latch into a known state.

The three "count" busses are the internal counters of the divider chain formed
by IC2, IC3, IC4.

### single_frame.pdf

"active_v" shows the active part of 1 frame (i.e., everything
apart from vertical blanking). "active_h" shows the active part of each scan-line
in the frame (and therefore there should be 16 lines * 16 scan-lines of them
within a frame).

"vdu_line" is the part of the address that defines the output line that is being
read from the video RAM. Immediately, one mystery of the NASCOM video addressing
is revealed: this bus counts from f (15) through 0 and up to e during the active
part of the frame. This shows how "line 16" comes to be at the top of the
frame. The waveforms also suggest that if "av_clr" and "av_set" were swapped,
the active region would be shifted along by 1 row time, so that "line 16" would
be at the bottom of the screen. ("av_clr", "av_set" are the outputs from IC8,
IC9).

I wonder whether this mod. would be sufficient, or whether it would also be
necessary to adjust the position of the vertical sync pulse?

### single_line.pdf

Shows one output line of characters, made up of 16 scan-lines. When "vdu_line"
has a value of f, the top line of the frame is being generated. "chr_rs" counts
from 0 through f, generating the row selects into the character
generator. "active_v" asserts and remains asserted because this is the start of
a video frame. "active_h" pulses high 16 times; once for each scan-line. "s2" is
the horizontal sync pulse. "vid_data" is toggling during the active part of each
line (it is gated out by "active_h", "active_v" the rest of the time, by IC11c).

### single_scanline.pdf

Shows one scan line. "vdu_line" is f and "chr_rs" is 0, showing that this is the
first scan-line at the top of the frame; this is confirmed by seeing "active_v"
assert. "ah_set", "ah_clr" 'bracket' the active part of the line, making
"active_h" assert. "clk_char_ld" pulses once per character. The resolution's a
bit low, but it should be possible to see:

* "mux_a" (the video RAM address) count though the locations of one row in one
period of "active_h"

* 64 pulses on "clk_char_ld" in one period of active_h

* (of which) 48 pulses occur while "active_h" is high

Remember, the operation of the video RAM, character generator etc. continues
through horizontal blanking; it's simply not visible because it's gated out of
"vid_data".

### hblank_to_7chars.pdf

Zooms in further to the start of the first scan line. As before, "vdu_line" is
f, "chr_rs" is 0, "active_v" asserts. The first visible character for line 16
comes from video RAM address 0x0bca. The base address of the video RAM is 0x800,
so address 0x0bca corresponds to address 0x3ca in the video RAM. Observe the
value 0x3ca on "mux_a". Where the value changes from 0x3ca to 0x3cb, the data
(the ASCII code for the first character to be displayed) is clocked into IC17
and used, along with the 0 from "chr_rs", to access a location in the character
generator. One character time later (when "mux_a" changes to 0x3cc) the
bit-pattern from the character generator is loaded into the shift register IC15
and "active_h" goes high, so that the display is enabled for the first dot of
the first scan-line of the first row of the first line.

In the simulation models, the output from the character generator is a constant
0x55 pattern, giving 3 high-pulses on "vid_data" for each output character.

TODO explain where the extra bit comes from.. the waves and the description
don't match..

### 14chars_to_hblank.pdf

Shows the end of the first scan line. The value 0x3f9 on "mux_a" corresponds to
the (first scan-line of the) last character on line 16, and the same 'pipe-line'
occurs as before, so that "active_h" goes low after the last dot of the
character is shifted out of the shift register.

## NASCOM 2 simulation waveforms

As of April 2020 this is a Coronavirus Lockdown work-in-progress project. The N2
sim is just about working but with some bugs. Hassle me to make progress if you
are interested!

The NASCOM 2 video design is software compatible with the NASCOM 1. Its
implementation is slightly different (it uses a small PROM as a logic decoder to
reduce the component count). Functionally, there are two differences:

* The number of video scan-lines per character line is either 12 or 14; on the
  NASCOM 1 it is fixed at 16.

* The way of coping with contention from CPU accesses is different. On the
  NASCOM 1 CPU contention caused white streaks ("snow") on the display. On the
  NASCOM 2 CPU contention caused parts of the scan line to be blanked -- less
  objectionable but not ideal; in the limit, executing code from the VDU RAM
  caused the screen to be permanently blanked.

Successive pictures 'zoom in' to different parts of the frame:

* doc/n2startup_frames.pdf    -- shows the 50 frame/second timing for 2 frame-times
* doc/n2single_scanline.pdf   -- shows the timing for one scan-line
* doc/n2single_line.pdf       -- shows the timing for one output line, 14 scan-lines
* doc/n2single_frame.pdf      -- shows the timing for the active part of a single frame
* doc/n2hblank_to_7chars.pdf  -- shows the start of one scan-line
* doc/n214chars_to_hblank.pdf -- shows the end of one scan-line

### n2startup_frames.pdf

This picture shows 2 complete video frame times (active and blanking). The black
regions of the waveform show signals that are toggling too quickly for all the
transitions to be visible at this zoom level.

All the remaining pictures show the same set of signals, zooming in to show
different detail.

Follow the schematic as you read these notes and look at the waveforms. Inspect
n2_vid.v and see how it relates to the schematic. Trace signal names from the
waveform to n2_vid.v and mark them up on your schematic; this will give you the
best chance of following the descriptions here.

Everything starts with the crystal XT1, centre-right on the schematic. Two
section of IC65 forms a crystal oscillator running at a frequency of 16MHz. The
oscillator output, "clk" blocks IC49 which is configured as a down-counter.

IC49 to generates outputs at 8MHz, 4MHz, 2MHz and 1MHz, each with a nominal
50/50 duty cycle, and "clk_1mhz_pulse" which is normally high but with a
low-going pulse at a 1MHz rate. A LSW selects between 2MHz and 4MHz clocks for
the CPU clock.

"clk_8mhz" is used as the dot (pixel) clock and clocks the video shift register,
IC65.

Each character is 8 dots (bits) wide. The 8 bits are read from one of the
character generators IC54, IC66 and loaded into IC65. IC65 must be loaded every
8 dot-times, ie at clk_8mhz/8.

IC65 is loaded by "clk_char_ld". IC71a combines the 1, 2, 4 and 8MHz clocks
together to generate this signal, which has a short low-going pulse at a 1MHz
rate (later waveforms show the relationship between "clk_1mhz_pulse" and
"clk_char_ld").


### n2single_scanline.pdf

Shows one scan line. "vdu_line" is 0xf and "vdu_rs" is 0, showing that this is
the first scan-line of the top line of the frame; this is confirmed by seeing
"active_v" assert.

IC51 and IC52 are clocked by "clk_1mhz_pulse" to generate a 6-bit counter
"vdu_chr". This counts one line time. It is used to address 64 successive
locations in the video RAM, IC50, via address MUX IC62, IC63. 48 of the
locations are displayed, 16 are hidden.

Decodes formed by IC55, IC56 generate set and reset pulses to the RS latch
formed by IC60. IC60/3 is "active_h" (or, to think of its inverse, /HBLANK). As
"vdu_chr" counts from 0 to 0x3f (63), the latch is set ("ah_set_n") as the count
goes to 0xc (12) and cleared ("ah_clr_n") as the count goes to 0x3c (60) ao that
"active_h" is asserted for a count of 48.

Each time "vdu_chr" wraps from 0x3f..0, the high->low transition of the count
MSB triggers IC57/1 to generate "hsync", the horizontal sync pulse to the vdu.

"clk_char_ld" pulses once per character. The resolution's a bit low, but it
should be possible to see:

* "mux_a" (the video RAM address) count though the locations of one row in one
period of "active_h"

* 64 pulses on "clk_char_ld" in one period of active_h

* (of which) 48 pulses occur while "active_h" is high


### n2single_line.pdf

Starts at the same point as n2single_scanline.pdf but zooms out to show one
output line of characters, made up of 14 scan-lines.

"vdu_line" is 0xf and "vdu_chr" is counting too quickly to be readable at this
resolution. "vdu_rs" is counting from 0 to 0xd (13), to count out the 14
scanlines of the top line of characters. As "vdu_rs" wraps from 0xd to 0,
"vdu_line" counts from 0xf to 1, the start of the second line of output.

IC53 and IC44c generate "vdu_rs". Each time "vdu_chr" wraps from 0x3f..0, the
high->low transition of the count MSB is inverted to generate a rising edge on
the clock input, IC43/2. When the count value reaches 14 (or 12, depending upon
the setting of LSW1/6) the counter is asynchronously cleared by "rs_rst_n". That
means the count value of 0xe (14) only persists for a short time (related to
gate delays - the reset pulse is truncated by its effect of resetting the count)
so that the count value appears to go from 0xd to 0.

"vdu_rs" is used to address one-of-16 rows within the character generator
ROMs, to build up successive scan lines for a line of characters.

### n2single_frame.pdf

Starts at the same point as n2single_line.pdf but zooms out to show one full
frame, made up of 16 lines of characters, each made up of 14 scan-lines.

"vdu_chr" and "vdu_rs" are counting too quickly to be readable at this
resolution. "vdu_line" counts from 0xf through 0 to 0xe for the 16 lines of the
active part of the display, then counts 0xf, 0x0, 0xb, 0xc, 0xd, 0xe for the
vertical blanking time. When it transitions from 0xe to 0xf this is the start of
the active region of the next frame.

The counters for this final part of the frame timing are formed by IC68, IC13b
and the N2V PROM.

IC68 is clocked using the same trick as IC53: when vid_rs is reset, the
high->low transition of the count MSB is inverted to generate a rising edge on
IC68/5. With no interference, the counter would count modulo 16.

As the counter IC68 wraps from 0xf to 0, its carry output clocks IC13/b which is
configured as a divide-by-2. The 4 bits of "vdu_line" are enough to count the
active part of the video frame. The addition of the extra counter bit from the
divide-by-2 provides the range to be able to count both the active and the
blanking part of the video frame. However, as the waveforms show, it's not
simply the case that this extra bit indicates active/blanking, it's a bit more
complicated.. I named this extra bit from the divide-by-2 "vdu_line_hi" (I made
up this name but I am not happy with it).

"vdu_line" is used to address 16 successive groups of locations in the video
RAM, IC50, via address MUX IC64.

"vdu_line", and a fifth bit "vdu_line_hi" address the N2V PROM. This PROM acts
as a decoder or look-up table. It has 8 outputs but only 2 are used/shown on the
circuit diagram.

The outputs of the PROM are shown as "active_v" (/VBLANK on the schematic) and
"vsync_trigger_n". "active_v" is easy to describe: it is high for the 16
character lines that form the active part of the display. "vsync_trigger_n" is
more subtle, and it's best to inspect the contents of file "prom_n2v.v" to
understand its operation (there are additional comments in that file).

During the active part of the frame, "vdu_line" transitions from 0->1 with
"vdu_line_hi"=1. During the blanking part of the frame, "vdu_line" transitions
from 0->1 and "vdu_line_hi"=0, the PROM decodes a 0 on "vsync_trigger_n". This
generates an asynchronous pulse on the /LOAD input of IC68 -- similar to the way
in which the decode of vdu_rs reset IC53.

The D/C/B/A inputs of IC53 are hard-wired to 0b1011 (11) and so the /LOAD pulse
sets the count value to 0xb. Just as for IC53, the load is asynchronous and
fast, and the change in the count value causes the /LOAD pulse to release; the
waveforms show a very short pulse on "vsync_trigger_n".

Aborting the "vdu_line" count in this way is the final step in establishing the
video frame timing. The period of "active_v" shows the frame period. The
simulation test bench reports this period, which stabilises at 19712us
(50.73Hz).

The falling edge of "vsync_trigger_n" triggers monostable IC57/10 to generate
"vsync", the vertical sync pulse to the vdu.

"vsync" and "hsync" are combined in IC61. The combined signal, "vid_sync" goes
through R69 to the modulator/video output. The voltage swing distinguishes sync
from video, and the pulse width distinguishes horizontal from vertical sync
pulses.

N2VPROM looks like an expensive solution to a trivial logic decode problem.


### n2hblank_to_7chars.pdf

Now that we've seen the whole frame, we're zooming in again, to see the start of
the first active scan line. See "active_v" assert, "vdu_line" is 0xf, "vdu_rs"
is 0, "vdu_chr" is zero.

The documentation shows that the first visible character for line 16 comes from
video RAM address 0x0bca. The base address of the video RAM is 0x800, so address
0x0bca corresponds to address 0x3ca in the video RAM, IC50. Pins A[9:6] of the
RAM select the line of the display (0-15) and pins A[5:0] select the charactor
on the line (0-63).

The value on "mux_a" is the concatenation of "vdu_line" and "vdu_chr" so it's
value starts at 0x3c0 and increments. When the value changes from 0x3ca to
0x3cb, the data from the RAM, on chr_d (the ASCII code for the first character
to be displayed) is clocked into IC67 on the rising edge of "clk_char_ld". The
output, "chr_a" is used as part of the address for the character generator ROMs.

"chr_a[7]" (from bit[7] of the byte stored in the video RAM) selects between the
alphanumerics character generator ROM and the NAS-GRA ROM. For each 2Kbyte ROM,
the 4-bit "vdu_rs" is connected to the low-order address lines to select one of
16 rows (though only 14 are used). "chr_a[6:0]" provide the other 7 address
lines, selecting one of 128 characters in the particular ROM.

One character time later (when "mux_a" changes to 0x3cc) the bit-pattern from
the character generator is loaded into the shift register IC65 and "active_h"
goes high, so that the display is enabled for the first dot of the first
scan-line of the first row of the first line.

In the simulation models, the output from the character generator is a constant
0x93 pattern. Shift register IC65 serialises its H input first, which is the MSB
from the character generator. So, the 0x93 is serialised MSB first, as 10010011.

In the simulation models, the output from the character generator is a constant
0x55 pattern, giving 3 high-pulses on "vid_data" for each output character.

The process of addressing the video RAM and generating a serial video stream
goes on continuously, including during horizontal blanking and vertical blanking
times. It is the signals active_h, active_v which inhibit (in IC61a)
"vid_shift_data" to generate the "blanked" signal, "vid_data" which goes to the
modulator/video output.


### n2char_pipeline.pdf

Zooms in further to show the pipeline from the first visible character being
addressed, to that characters data coming out of the shift register.


### n214chars_to_hblank.pdf

Shows the end of the first scan line. The value 0x3f9 on "mux_a" corresponds to
the (first scan-line of the) last character on line 16, and the same pipe-line
occurs as before, so that "active_h" goes low after the last dot of the
character is shifted out of the shift register. At the end of the line, "mux_a"
wraps from 0x3ff to 0x3c0 - it cycles back over the same sequence of video RAM
addresses in order to generate the next scan line for this line of characters.


## Z80 access to video RAM (no .pdf for this)

Access to the video RAM is shared between the video circuitry and the Z80
CPU. The CPU has read-write access and the video circuitry has read-only
access. CPU access takes priority; when the CPU accesses the video RAM, /VRAM
asserts (a decode of /MREQ and the address bus). These things happen:

* /VRAM switches the address MUXes IC62, IC63, IC64 so that the address to the
  video RAM is supplied by the CPU instead of the video address counters.

* /VRAM triggers a monostable chain formed by IC58b, IC58a (more on that later).

* /VRAM enables the data buffer, IC70 pin 11, and inverted CPU /RD controls its
  direction (pin 11) to allow data from the CPU to flow through to the video RAM
  data bus, or the reverse.

* /VRAM is gated with the CPU write strobe (IC59c) to generate the video RAM
  /WE. If /VRAM is high (no CPU access), /WE is negated. If /VRAM is low (CPU
  access), /WE follows the CPU /WR strobe.

* /VRAM is gated with the CPU read strobe (IC69b on sheet 3) to generate the
video RAM /OE. If /VRAM is high (no CPU access), /OE is asserted. If /VRAM is low
(CPU access), /OE follows the CPU /RD strobe.

IC67 continues to clock values to address the character generator, even when CPU
accesses occur. As a result, incorrect values get clocked into IC67, which
result in corrupted pixels in the video stream. The purpose of monostables IC58
is to prevent these corrupted pixels from appearing on the display. A CPU access
triggers a high-going pulse on IC58/5. The end of the pulse triggers a low-going
pulse on IC58/4. This pulse is gated with the horizontal and vertical blanking
signals in IC61a. The effect of the monostables is to insert a black region in
the scan-line which should coincide with the time at which the corrupted data is
being shifted out of IC65. The pulse width of IC58b should delay the start of
the black region, to correspond to the pipeline delay between the data
corruption and the output of the video RAM IC50 and the associated data
corruption at the output of the shift register IC65. The pulse width of IC58a
should correspond to 8 bit-times.

(By inspection on my hardware, both of those times are longer than I would
expect to be necessary. Strictly, the best times are a function of the CPU
frequency.

This part of the design fixes the "white snow" effect seen on the NASCOM 1 but
excessive CPU access to video RAM causes the blanking pulses to be noticable,
particularly on a display where many pixels are lit. A simple test program that
accesses the video RAM can show this:

````
  0c80   3a 00 08  ld a, (£0800)
  0c83   32 00 08  ld (£0800), a
  0c86   00        nop
  0c87   00        nop
  0c88   00        nop
  0c89   00        nop
  0c8a   00        nop
  0c8b   00        nop
  0c8c   c3 80 0c  jp £0c80
````

When executed, black stripes appear on the screen.


## How to run it yourself

I use Linux. Your mileage may vary.

* Download and install Icarus Verilog

* Download and install GTKWave

Do this:

    $ ./doitall1                         # or ./doitall2
    (wait)
    (load the .vcd file into GTKWave)


## Futures

* Generate some Z80 bus traffic to show it interfering with the video
access.

* Model the RAM and character generator

* The counters have an "initial" statement in them to establish the count at
time 0. It would be better to put a 'force' into the test-bench as it would be
more apparent what is going on (search for CHEAT and CHEATING in the code).

* Describe CPU accesss to video RAM and discuss the shortcomings of CPU
contention mitigation which causes white snow on the NASCOM 1 and black snow(??)
on the NASCOM 2.

* Rework the N1 waves to make them clearer, and explain/debug the issue with
shift register load.


## Comments/improvements

* Email me or use the 'issues' button at the top on the github page.

* Fork the project and make a merge request
