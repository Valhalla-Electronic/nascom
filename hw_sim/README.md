# RTL Simulation of Nascom 1 video sub-system

## Introduction

Although I have stared at the Nascom 1 and Nascom 2 schematics, and understand
in general terms how the video circuitry works, the fine detail of it has always
eluded me.

In particular, I'd like to know: how did we end up with row 16 at the top of the
screen instead of at the bottom? There is no sensible reason for choosing to do
it like this. Was it a design bug, not found until too late? Was it a
side-effect of saving a chip or two?

To find out, and understand the operation better, I wrote a verilog net-list of
the Nascom 1 video schematic, created models of the components and ran an RTL
simulation. I used the open-source "Icarus Verilog" simulator and the
open-source GTKWave viewing tool.

I present some .pdf files that show the video timing in gory detail. I also
present the netlist and models in case anyone wants to develop the idea further.

## Files

* nas1_vid.v -- Verilog netlist of the Nascom 1 video sub-system. Created by hand
  from examination of the schematics. I have named all of the signals. To make
  detailed sense of it you need to print out some N1 schematics and annotate the
  names by inspecting nas_vid.v.

* nas1_vid_tb.v -- Verilog test-bench to
  control the simulation, apply clocks, gather waveforms.

* doitall1 -- script to rebuild the simulation executable

* doc/ -- contains .pdf files of waveforms, so that you can see the results of
  the simulation without having to run it yourself. These are described in
  detail below.

* other *.v files are (simple) verilog models of the components that make up the video
  sub-system.

## TODO/Futures

The counters have an "initial" statement in them to establish the count at time 0. It
would be better to put a 'force' into the test-bench as it would be more apparent what is
going on..

Search for CHEAT and CHEATING in the code.

## Overview

A couple of things to note: Firstly, this is only a functional (logical)
simulation, there is no timing information (i.e., the Verilog models do not
model the timing of the TTL gates, only their behaviour). Secondly, I have not
(yet) troubled to model the video RAM or the character generator; I have just
put fixed data on the output of the character generator.

The nascom video circuit produces 16 lines of characters, with 48
characters per line. The horizontal timing is 64 character-times long and the
RAM access continues during the non-visible region, so that each line of
characters starts in RAM on a multiple of 64 (which is convenient, because it's
a power of 2).

Each line of characters is made up (vertically) of 16 raster scan-lines on the
video output and (horizontally) of 8 dots of light (1) or not (0) on the
phosphor of the CRT.

The scan-lines of a line are generated by reading the same sequence of 64 video
RAM locations, 16 times. Each time, the RAM returns the same value (the 7-bit
ASCII code of the character to be displayed) and a 4-bit counter increments.
Together, the ASCII code and the 4-bit count are used to address the character
generator, to get the 8-bit value that represents the 8 dots for this 1/64th
part of this scan-line.

OK, on to the pictures. Successive pictures 'zoom in' to parts of the frame:

* doc/startup_frames.pdf    -- shows the 50 frame/second timing start up after 2 frame-times
* doc/single_frame.pdf      -- shows the timing for the active part of a single frame
* doc/single_line.pdf       -- shows the timing for one output line, 16 scan-lines
* doc/single_scanline.pdf   -- shows the timing for one scan-line
* doc/hblank_to_7chars.pdf  -- shows the start of one scan-line
* doc/14chars_to_hblank.pdf -- shows the end of one scan-line

### startup_frames.pdf

div16 is a 50Hz signal from the divider chain. There is 1 output
frame for each cycle of this signal. Observe that it takes several cycles for
the correct frequency to be established (the correct timing has been established
when the low-time is shorter than the high-time).

The black regions of the waveform show signals that are toggling too quickly for
all the transitions to be visible at this zoom level. The shaded regions (on
active_v) show a signal in an undefined state; it takes the av_set pulse to
bring this latch into a known state.

The three 'count' busses are the internal counters of ic2, ic3, ic4; the last
stages of the main divider chain.

### single_frame.pdf

active_v shows the active part of 1 frame (i.e., everything
apart from vertical blankin). active_h shows the active part of each scan-line
in the frame (and therefore there should be 16 lines * 16 scan-lines of them
within a frame).

vdu_line is the part of the address that defines the output line that is being
read from the video RAM. Immediately, one mystery of the Nascom video addressing
is revealed: this bus counts from f (15) through 0 and up to e during the active
part of the frame. This shows how "line 16" comes to be at the top of the
frame. The waveforms also suggest that if av_clr and av_set were swapped, the
active region would be shifted along by 1 row time, so that "line 16" would be
at the bottom of the screen. (av_clr, av_set are the outputs from ic8, ic9).

I wonder whether this mod. would be sufficient, or whether it would also be
necessary to asjust the position ov the vertical sync pulse.

### single_line.pdf

Shows one output line of characters, made up of 16 scan-lines. vdu_line=f
showing that this is the top line of the frame. chr_rs counts from 0 through f,
generating the row selects into the character generator. active_v asserts and
remains asserted because this is the start of a video frame. active_h pulses
high 16 times; once for each scan-line. s2 is the horizontal sync
pulse. vid_data is toggling during the active part of each line (it is gated out
by active_h, active_v the rest of the time, by ic11c).

### single_scanline.pdf

Shows one scan line. vdu_line=f and chr_rs=0, showing that this is the first
scan-line at the top of the frame; this is confirmed by seeing active_v
assert. ah_set, ah_clr 'bracket' the active part of the line, making active_h
assert. clk_char_ld pulses once per character. The resolution's a bit low, but
it should be possible to see:

* mux_a (the video RAM address) count though the locations of one row in one period of active_h

* 64 pulses on clk_char_ld in one period of active_h

* (of which) 48 pulses occur while active_h is high

Remember, the operation of the video RAM, character generator etc. continues
through horizontal blanking; it's simply not visible because it's gated out of
vid_data.

### hblank_to_7chars.pdf

Zooms in further to the start of the first scan line. As before, vdu_line=f,
chr_rs=0, active_v asserts. The first visible character for line 16 comes from
address 0x0bca. The base address of the video RAM is 0x800, so address 0x0bca
corresponds to address 0x3ca in the video RAM. Observe the value 0x3ca on
mux_a. Where the value changes from 0x3ca to 0x3cb, the data (the ASCII code for
the first character to be displayed) is clocked into IC17 and used, along with
the 0 from chr_rs, to access a location in the character generator. One
character time later (when mux_a changes to 0x3cc) the bit-pattern from the
character generator is loaded into the shift register ic15 and active_h goes
high, so that the display is enabled for the first dot of the first scan-line of
the first row of the first line.

In the simulation models, the output from the character generator is a constant
0x55 pattern, giving 3 high-pulses on vid_data for each output character.

### 14chars_to_hblank.pdf

Shows the end of the first scan line. The value 0x3f9 on mux_a corresponds to
the (first scan-line of the) last character on line 16, and the same 'pipe-line'
occurs as before, so that active_h goes low after the last dot of the character
is shifted out of the shift register.

## How to run it yourself

I use Linux. Your mileage may vary.

* Download and install Icarus Verilog

* Download and install GTKWave

Do this:

    $ ./doitall
    $ ./nas_vid
    (wait)
    (load the .vcd file into GTKWave)


## Futures

* Generate some Z80 bus traffic to show it interfering with the video
access.

* Model the RAM and character generator

* Do a Nascom 2 version.

## Comments/improvements

* Email me or use the 'issues' button at the top on the github page.

* Fork the project and make a merge request
